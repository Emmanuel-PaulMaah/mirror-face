<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Full Body Mirror Tracking (Face + Body + Hands)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#111;color:#ddd;font:14px system-ui}
    .app{display:grid;grid-template-columns:1fr 360px;grid-template-rows:100vh}
    .view{position:relative;overflow:hidden}
    .sidebar{display:grid;grid-template-rows:1fr auto;gap:8px;padding:8px;overflow-y:auto}
    #ui{background:#1b1b1b;border:1px solid #333;padding:10px;border-radius:8px}
    #camWrap{position:relative;border:1px solid #333;border-radius:6px;overflow:hidden}
    #video{display:block;width:100%;height:auto;object-fit:cover;opacity:.9}
    #overlay{position:absolute;inset:0;pointer-events:none}
    #morphKeys{max-width:100%;max-height:110px;overflow:auto;font-family:monospace;background:#0f0f0f;padding:6px;border:1px solid #222;border-radius:6px;font-size:11px}
    canvas#three{display:block;width:100%;height:100%}
    .err{color:#e37b7b}
    .info{font-size:12px;color:#888;margin-top:8px}
    label{display:block;margin-top:8px;font-weight:600;font-size:12px}
  </style>
</head>
<body>
  <div class="app">
    <div class="view">
      <canvas id="three"></canvas>
    </div>

    <div class="sidebar">
      <div id="ui">
        <div><b>Full Body Mirror Tracking</b></div>
        <label>Upload GLB/GLTF (rigged character with skeleton)</label>
        <input type="file" id="file" accept=".glb,.gltf" />
        <label>Detected morph target keys</label>
        <div id="morphKeys"></div>
        <div class="info">✨ MediaPipe Face (52 ARKit blendshapes) + Pose (body) + Hands tracking!</div>
        <div id="status">Waiting for model…</div>
      </div>

      <div id="camWrap">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/+esm";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js/+esm";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js/+esm";

    const canvas = document.getElementById('three');
    const statusEl = document.getElementById('status');
    const morphKeysEl = document.getElementById('morphKeys');
    const overlay = document.getElementById('overlay');
    const video = document.getElementById('video');

    // Scene
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    const scene = new THREE.Scene(); 
    scene.background = new THREE.Color(0x111111);
    const camera = new THREE.PerspectiveCamera(35, 1, 0.01, 100); 
    camera.position.set(0,1.2,2.2);
    const hemi = new THREE.HemisphereLight(0xffffff,0x222233,1.1); scene.add(hemi);
    const dir  = new THREE.DirectionalLight(0xffffff,1.1); dir.position.set(2,3,2); scene.add(dir);
    const grid = new THREE.GridHelper(6,12,0x333333,0x222222); grid.position.y=-1; scene.add(grid);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 0.5;
    controls.maxDistance = 10;
    controls.enablePan = true;
    controls.target.set(0, 1, 0);

    function frameObject(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const sizeV = box.getSize(new THREE.Vector3());
      const size = Math.max(sizeV.x, sizeV.y, sizeV.z);
      const center = box.getCenter(new THREE.Vector3());
      const fitHeight = size / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)));
      const fitWidth  = fitHeight / camera.aspect;
      const dist = 1.2 * Math.max(fitHeight, fitWidth);
      camera.near = Math.max(0.01, size / 100);
      camera.far  = Math.max(100, size * 10);
      camera.position.copy(center).add(new THREE.Vector3(0, size * 0.15, dist));
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();
    }

    function resize(){
      const view = canvas.parentElement.getBoundingClientRect();
      renderer.setSize(view.width, view.height, false);
      camera.aspect = view.width / view.height;
      camera.updateProjectionMatrix();
      const vr = document.getElementById('video').getBoundingClientRect();
      overlay.width  = Math.max(1, Math.floor(vr.width));
      overlay.height = Math.max(1, Math.floor(vr.height));
    }
    addEventListener('resize', resize);
    new ResizeObserver(resize).observe(document.body);
    resize();

    (function loop(){
      requestAnimationFrame(loop);
      controls.update();
      renderer.render(scene, camera);
    })();

    let morphRefs = [];
    const gltfLoader = new GLTFLoader();

    function collectMorphMeshes(root){
      const out=[]; 
      root.traverse(o=>{
        if(o.isMesh && o.morphTargetDictionary && o.morphTargetInfluences){
          out.push({ dict:o.morphTargetDictionary, inf:o.morphTargetInfluences });
        }
      });
      return out;
    }

    function unionMorphKeys(refs){
      const s=new Set();
      refs.forEach(r=>Object.keys(r.dict).forEach(k=>s.add(k)));
      return Array.from(s).sort();
    }

    // Store original bone rotations (rest pose)
    let neckRestQuat = null, headRestQuat = null;

    document.getElementById('file').addEventListener('change', async (e)=>{
      const file = e.target.files?.[0]; if(!file) return;
      statusEl.textContent = 'Loading model…';
      const url = URL.createObjectURL(file);
      try{
        const gltf = await gltfLoader.loadAsync(url);
        gltf.scene.position.set(0,-1,0);
        scene.add(gltf.scene);
        frameObject(gltf.scene);

        morphRefs = collectMorphMeshes(gltf.scene);

        // Find BOTH neck and head bones
        let neckNode = null, headNode = null;
        gltf.scene.traverse(o=>{
          if(o.isBone || o.isObject3D){
            const n = o.name.toLowerCase();
            // Neck detection
            if(!neckNode && (/neck/i.test(o.name) || /spine.*3/i.test(o.name) || /cervical/i.test(o.name))){
              neckNode = o;
            }
            // Head detection
            if(!headNode && (/\bhead\b/i.test(o.name) || /Head_JNT/i.test(o.name) || /DEF-Head/i.test(o.name) || /mixamorigHead/i.test(o.name))){
              headNode = o;
            }
          }
        });

        // Fallback: if no neck found but head found, use head's parent as neck
        if(headNode && !neckNode && headNode.parent && headNode.parent !== gltf.scene){
          neckNode = headNode.parent;
        }

        window.neckNode = neckNode;
        window.headNode = headNode || gltf.scene;
        
        // CRITICAL FIX: Store original rest pose instead of zeroing
        if(neckNode && neckNode.quaternion) {
          neckRestQuat = neckNode.quaternion.clone();
        }
        if(headNode && headNode.quaternion) {
          headRestQuat = headNode.quaternion.clone();
        }

        console.log('Bones found:', { 
          neck: neckNode?.name, 
          head: headNode?.name,
          neckRest: neckRestQuat,
          headRest: headRestQuat
        });

        // Find body bones for pose tracking
        bodyBones = findBodyBones(gltf.scene);

        if(morphRefs.length===0){ 
          statusEl.innerHTML = '<span class="err">No morph targets found.</span>'; 
          return; 
        }

        const keys = unionMorphKeys(morphRefs);
        morphKeysEl.textContent = keys.join(', ');
        statusEl.textContent = 'Model ready. Starting webcam + tracking…';
      }catch(err){ 
        console.error(err); 
        statusEl.innerHTML = '<span class="err">Model load failed.</span>'; 
      }
      finally{ URL.revokeObjectURL(url); }
    });

    // Store body bone references and rest poses
    let bodyBones = {};
    
    function findBodyBones(root) {
      const bones = {};
      
      root.traverse(o => {
        if(o.isBone || o.isObject3D) {
          const name = o.name.toLowerCase();
          
          // Helper to create bone entry with rest direction
          const createBoneEntry = (node) => {
            const entry = { 
              node: node, 
              rest: node.quaternion.clone(),
              restDir: null  // Will store child direction in world space
            };
            
            // Find child bone to determine rest direction
            if (node.children && node.children.length > 0) {
              const child = node.children.find(c => c.isBone || c.isObject3D);
              if (child) {
                // Get direction from this bone to child in world space
                const worldPos = new THREE.Vector3();
                const childWorldPos = new THREE.Vector3();
                node.getWorldPosition(worldPos);
                child.getWorldPosition(childWorldPos);
                
                entry.restDir = {
                  x: childWorldPos.x - worldPos.x,
                  y: childWorldPos.y - worldPos.y,
                  z: childWorldPos.z - worldPos.z
                };
              }
            }
            
            // Fallback: use default Y-axis if no child found
            if (!entry.restDir) {
              entry.restDir = {x: 0, y: 1, z: 0};
            }
            
            return entry;
          };
          
          // Spine/torso
          if (!bones.spine && (/spine|torso/i.test(o.name) && !/spine.*3|neck/i.test(o.name))) {
            bones.spine = createBoneEntry(o);
          }
          
          // Shoulders
          if (!bones.leftShoulder && (/left.*shoulder|shoulder.*left|l.*clavicle/i.test(o.name))) {
            bones.leftShoulder = createBoneEntry(o);
          }
          if (!bones.rightShoulder && (/right.*shoulder|shoulder.*right|r.*clavicle/i.test(o.name))) {
            bones.rightShoulder = createBoneEntry(o);
          }
          
          // Upper arms
          if (!bones.leftUpperArm && (/left.*arm|arm.*left|l.*upper.*arm|upper.*arm.*left/i.test(o.name) && !/lower|forearm/i.test(o.name))) {
            bones.leftUpperArm = createBoneEntry(o);
          }
          if (!bones.rightUpperArm && (/right.*arm|arm.*right|r.*upper.*arm|upper.*arm.*right/i.test(o.name) && !/lower|forearm/i.test(o.name))) {
            bones.rightUpperArm = createBoneEntry(o);
          }
          
          // Lower arms
          if (!bones.leftLowerArm && (/left.*forearm|forearm.*left|l.*lower.*arm|lower.*arm.*left/i.test(o.name))) {
            bones.leftLowerArm = createBoneEntry(o);
          }
          if (!bones.rightLowerArm && (/right.*forearm|forearm.*right|r.*lower.*arm|lower.*arm.*right/i.test(o.name))) {
            bones.rightLowerArm = createBoneEntry(o);
          }
          
          // Hands
          if (!bones.leftHand && (/left.*hand|hand.*left|l.*wrist/i.test(o.name))) {
            bones.leftHand = createBoneEntry(o);
          }
          if (!bones.rightHand && (/right.*hand|hand.*right|r.*wrist/i.test(o.name))) {
            bones.rightHand = createBoneEntry(o);
          }
          
          // Hips
          if (!bones.hips && (/hips|pelvis|root/i.test(o.name))) {
            bones.hips = createBoneEntry(o);
          }
          
          // Legs
          if (!bones.leftUpperLeg && (/left.*thigh|thigh.*left|l.*upper.*leg|upper.*leg.*left/i.test(o.name))) {
            bones.leftUpperLeg = createBoneEntry(o);
          }
          if (!bones.rightUpperLeg && (/right.*thigh|thigh.*right|r.*upper.*leg|upper.*leg.*right/i.test(o.name))) {
            bones.rightUpperLeg = createBoneEntry(o);
          }
          if (!bones.leftLowerLeg && (/left.*shin|shin.*left|l.*lower.*leg|lower.*leg.*left|left.*calf/i.test(o.name))) {
            bones.leftLowerLeg = createBoneEntry(o);
          }
          if (!bones.rightLowerLeg && (/right.*shin|shin.*right|r.*lower.*leg|lower.*leg.*right|right.*calf/i.test(o.name))) {
            bones.rightLowerLeg = createBoneEntry(o);
          }
        }
      });
      
      console.log('Body bones found:', Object.keys(bones).map(k => `${k}: ${bones[k].node.name}`));
      return bones;
    }

    window.__rigShared__ = {
      get morphRefs(){return morphRefs;},
      get neckRestQuat(){return neckRestQuat;},
      get headRestQuat(){return headRestQuat;},
      get bodyBones(){return bodyBones;}
    };
  </script>

  <!-- MediaPipe Face, Pose, and Hand Tracking -->
  <script type="module">
    import { FaceLandmarker, PoseLandmarker, HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";
    
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const statusEl = document.getElementById('status');

    let faceLandmarker, poseLandmarker, handLandmarker;
    let lastVideoTime = -1;

    // Smoothing for blendshapes and rotation
    const ema = alpha => { 
      let val = 0, init = false; 
      return v => { val = init ? (alpha*v + (1-alpha)*val) : (init=true, v); return val; }; 
    };

    const blendshapeFilters = {};
    let rotQuat = {x:0, y:0, z:0, w:1};

    function qNormalize(q){
      const m = Math.hypot(q.x,q.y,q.z,q.w)||1; 
      return {x:q.x/m, y:q.y/m, z:q.z/m, w:q.w/m};
    }

    function qMultiply(a, b) {
      return {
        w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
        x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
        y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
        z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
      };
    }

    function qSlerp(a, b, t){
      let cos = a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w;
      if (cos < 0) { b = {x:-b.x, y:-b.y, z:-b.z, w:-b.w}; cos = -cos; }
      if (cos > 0.9995) {
        const x=a.x+(b.x-a.x)*t, y=a.y+(b.y-a.y)*t, z=a.z+(b.z-a.z)*t, w=a.w+(b.w-a.w)*t;
        return qNormalize({x,y,z,w});
      }
      const th = Math.acos(Math.min(1, cos));
      const s = Math.sin(th);
      const w1 = Math.sin((1-t)*th)/s, w2 = Math.sin(t*th)/s;
      return {x:a.x*w1+b.x*w2, y:a.y*w1+b.y*w2, z:a.z*w1+b.z*w2, w:a.w*w1+b.w*w2};
    }

    function matrixToQuaternion(m) {
      // m is 4x4 matrix as Float32Array (column-major)
      const m00=m[0], m01=m[4], m02=m[8];
      const m10=m[1], m11=m[5], m12=m[9];
      const m20=m[2], m21=m[6], m22=m[10];

      let qw, qx, qy, qz;
      const t = m00 + m11 + m22;
      if (t > 0) {
        const s = Math.sqrt(t + 1.0) * 2;
        qw = 0.25 * s;
        qx = (m21 - m12) / s;
        qy = (m02 - m20) / s;
        qz = (m10 - m01) / s;
      } else if (m00 > m11 && m00 > m22) {
        const s = Math.sqrt(1.0 + m00 - m11 - m22) * 2;
        qw = (m21 - m12) / s;
        qx = 0.25 * s;
        qy = (m01 + m10) / s;
        qz = (m02 + m20) / s;
      } else if (m11 > m22) {
        const s = Math.sqrt(1.0 + m11 - m00 - m22) * 2;
        qw = (m02 - m20) / s;
        qx = (m01 + m10) / s;
        qy = 0.25 * s;
        qz = (m12 + m21) / s;
      } else {
        const s = Math.sqrt(1.0 + m22 - m00 - m11) * 2;
        qw = (m10 - m01) / s;
        qx = (m02 + m20) / s;
        qy = (m12 + m21) / s;
        qz = 0.25 * s;
      }
      return qNormalize({x:qx, y:qy, z:qz, w:qw});
    }

    // Calculate quaternion rotation between two direction vectors
    function quatBetweenVectors(fromDir, toDir) {
      // Normalize input vectors
      const len1 = Math.sqrt(fromDir.x*fromDir.x + fromDir.y*fromDir.y + fromDir.z*fromDir.z);
      const len2 = Math.sqrt(toDir.x*toDir.x + toDir.y*toDir.y + toDir.z*toDir.z);
      
      if (len1 < 0.0001 || len2 < 0.0001) return {x:0, y:0, z:0, w:1};
      
      const v1x = fromDir.x/len1, v1y = fromDir.y/len1, v1z = fromDir.z/len1;
      const v2x = toDir.x/len2, v2y = toDir.y/len2, v2z = toDir.z/len2;
      
      const dot = v1x*v2x + v1y*v2y + v1z*v2z;
      
      // Vectors are parallel
      if (dot > 0.999999) return {x:0, y:0, z:0, w:1};
      
      // Vectors are opposite
      if (dot < -0.999999) {
        // Find perpendicular axis
        let perpX = 1, perpY = 0, perpZ = 0;
        if (Math.abs(v1x) > 0.9) {
          perpX = 0; perpY = 1;
        }
        return {x: perpX, y: perpY, z: perpZ, w: 0};
      }
      
      // Cross product for rotation axis
      const axisX = v1y*v2z - v1z*v2y;
      const axisY = v1z*v2x - v1x*v2z;
      const axisZ = v1x*v2y - v1y*v2x;
      
      const s = Math.sqrt((1 + dot) * 2);
      const invS = 1 / s;
      
      return qNormalize({
        x: axisX * invS,
        y: axisY * invS,
        z: axisZ * invS,
        w: s * 0.5
      });
    }

    // Smoothing filters for body bones
    const boneRotationFilters = {};

    function applyPoseTracking(poseLandmarks) {
      const shared = window.__rigShared__;
      if (!poseLandmarks || !shared?.bodyBones) return;
      
      const bones = shared.bodyBones;
      const lm = poseLandmarks;
      
      // MediaPipe Pose Landmark indices:
      // 11,12: shoulders | 13,14: elbows | 15,16: wrists | 23,24: hips | 25,26: knees | 27,28: ankles
      
      // Helper to apply bone rotation from landmarks
      const applyBoneRotation = (bone, fromLm, toLm, filterKey) => {
        if (!bone || !bone.restDir || !fromLm || !toLm) return;
        
        // Calculate current direction from landmarks
        const liveDir = {
          x: toLm.x - fromLm.x,
          y: toLm.y - fromLm.y,
          z: toLm.z - fromLm.z
        };
        
        // Calculate rotation from rest direction to live direction
        const deltaRot = quatBetweenVectors(bone.restDir, liveDir);
        
        // Apply smoothing
        if (!boneRotationFilters[filterKey]) boneRotationFilters[filterKey] = {q: deltaRot};
        boneRotationFilters[filterKey].q = qSlerp(boneRotationFilters[filterKey].q, deltaRot, 0.3);
        
        // Apply to bone: delta * rest (apply rest first, then delta)
        const final = qMultiply(boneRotationFilters[filterKey].q, bone.rest);
        bone.node.quaternion.copy(final);
      };
      
      // Apply rotations to all bones
      applyBoneRotation(bones.leftUpperArm, lm[11], lm[13], 'leftUpperArm');
      applyBoneRotation(bones.rightUpperArm, lm[12], lm[14], 'rightUpperArm');
      applyBoneRotation(bones.leftLowerArm, lm[13], lm[15], 'leftLowerArm');
      applyBoneRotation(bones.rightLowerArm, lm[14], lm[16], 'rightLowerArm');
      applyBoneRotation(bones.leftUpperLeg, lm[23], lm[25], 'leftUpperLeg');
      applyBoneRotation(bones.rightUpperLeg, lm[24], lm[26], 'rightUpperLeg');
      applyBoneRotation(bones.leftLowerLeg, lm[25], lm[27], 'leftLowerLeg');
      applyBoneRotation(bones.rightLowerLeg, lm[26], lm[28], 'rightLowerLeg');
    }

    function applyTracking(blendshapes, transformMatrix, poseLandmarks, handLandmarks) {
      const shared = window.__rigShared__;
      if(!shared?.morphRefs) return;

      // Apply pose tracking to body bones
      if (poseLandmarks) {
        applyPoseTracking(poseLandmarks);
      }

      // Apply head/neck rotation from transformation matrix
      if(transformMatrix && transformMatrix.data) {
        const headQuat = matrixToQuaternion(transformMatrix.data);
        const smoothness = 0.25;
        rotQuat = qSlerp(rotQuat, headQuat, smoothness);

        // Apply to neck (40% of rotation) and head (60% of rotation)
        if(window.neckNode && window.neckNode.quaternion && shared.neckRestQuat) {
          const neckRotation = qSlerp({x:0,y:0,z:0,w:1}, rotQuat, 0.4);
          const finalNeck = qMultiply(shared.neckRestQuat, neckRotation);
          window.neckNode.quaternion.copy(finalNeck);
        }

        if(window.headNode && window.headNode.quaternion && shared.headRestQuat) {
          const headRotation = qSlerp({x:0,y:0,z:0,w:1}, rotQuat, 0.6);
          const finalHead = qMultiply(shared.headRestQuat, headRotation);
          window.headNode.quaternion.copy(finalHead);
        }
      }

      // Apply all 52 native ARKit blendshapes from MediaPipe
      if(!blendshapes) return;

      // Convert blendshapes array to object for easier access
      const blendshapeMap = {};
      blendshapes.forEach(bs => {
        const name = bs.categoryName;
        const value = bs.score;
        
        // Apply smoothing
        if(!blendshapeFilters[name]) blendshapeFilters[name] = ema(0.35);
        blendshapeMap[name] = blendshapeFilters[name](value);
      });

      // Apply to morph targets
      for(const ref of shared.morphRefs){
        const keys = Object.keys(ref.dict);
        
        // Direct ARKit name matching
        for(const [shapeName, value] of Object.entries(blendshapeMap)){
          if(ref.dict[shapeName] !== undefined){
            ref.inf[ref.dict[shapeName]] = Math.max(0, Math.min(1, value));
          }
        }

        // Heuristic fallback for non-standard naming
        for(const key of keys){
          const lk = key.toLowerCase();
          
          // Eyes
          if(/blink.*left|eye.*close.*left|left.*blink/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.eyeBlinkLeft || 0;
          if(/blink.*right|eye.*close.*right|right.*blink/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.eyeBlinkRight || 0;
          if(/eye.*wide.*left|left.*eye.*wide/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.eyeWideLeft || 0;
          if(/eye.*wide.*right|right.*eye.*wide/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.eyeWideRight || 0;
          
          // Jaw
          if(/jaw.*open|mouth.*open/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.jawOpen || 0;
          if(/jaw.*left/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.jawLeft || 0;
          if(/jaw.*right/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.jawRight || 0;
          
          // Smile/Frown
          if(/smile/i.test(key)) 
            ref.inf[ref.dict[key]] = Math.max(blendshapeMap.mouthSmileLeft||0, blendshapeMap.mouthSmileRight||0);
          if(/frown/i.test(key)) 
            ref.inf[ref.dict[key]] = Math.max(blendshapeMap.mouthFrownLeft||0, blendshapeMap.mouthFrownRight||0);
          
          // Eyebrows
          if(/brow.*up.*left|left.*brow.*up/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.browOuterUpLeft || blendshapeMap.browInnerUp || 0;
          if(/brow.*up.*right|right.*brow.*up/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.browOuterUpRight || blendshapeMap.browInnerUp || 0;
          if(/brow.*down.*left|left.*brow.*down/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.browDownLeft || 0;
          if(/brow.*down.*right|right.*brow.*down/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.browDownRight || 0;
          
          // Mouth shapes
          if(/funnel|pucker|kiss/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.mouthFunnel || blendshapeMap.mouthPucker || 0;
          if(/puff|cheek/i.test(key)) 
            ref.inf[ref.dict[key]] = blendshapeMap.cheekPuff || 0;
        }
      }
    }

    function drawLandmarks(lm){
      const w = overlay.width, h = overlay.height;
      if(!w||!h) return;
      ctx.clearRect(0,0,w,h);
      ctx.lineWidth = Math.max(1, w/400);
      ctx.strokeStyle = '#00ff88';
      ctx.fillStyle = '#00ff88';

      // Draw landmark points
      ctx.beginPath();
      for(const p of lm){
        const x = p.x * w, y = p.y * h;
        ctx.moveTo(x+1, y);
        ctx.arc(x, y, Math.max(1, w/350), 0, Math.PI*2);
      }
      ctx.fill();

      // Face contour
      const outline = [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,
                       148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109];
      ctx.strokeStyle = '#00ffaa';
      ctx.beginPath();
      outline.forEach((i,ix)=>{
        const p = lm[i], x=p.x*w, y=p.y*h;
        if(ix===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }

    async function boot(){
      try {
        // Initialize MediaPipe models
        statusEl.textContent = 'Loading MediaPipe models (Face, Pose, Hands)...';
        const filesetResolver = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        // Face Landmarker
        faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
            delegate: "GPU"
          },
          outputFaceBlendshapes: true,
          outputFacialTransformationMatrixes: true,
          runningMode: "VIDEO",
          numFaces: 1,
          minFaceDetectionConfidence: 0.5,
          minFacePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        });

        // Pose Landmarker
        poseLandmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numPoses: 1,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        });

        // Hand Landmarker
        handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 2,
          minHandDetectionConfidence: 0.5,
          minHandPresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        });

        // Setup webcam
        statusEl.textContent = 'Requesting webcam access...';
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode:'user', width:640, height:480 }, 
          audio:false 
        });
        video.srcObject = stream;
        await video.play();

        const syncOverlay = ()=> {
          const vr = video.getBoundingClientRect();
          overlay.width  = Math.max(1, Math.floor(vr.width));
          overlay.height = Math.max(1, Math.floor(vr.height));
        };
        video.addEventListener('loadedmetadata', syncOverlay);
        new ResizeObserver(syncOverlay).observe(document.getElementById('camWrap'));

        // Start detection loop for all trackers
        function detectAll() {
          const nowInMs = Date.now();
          
          if (video.currentTime !== lastVideoTime) {
            lastVideoTime = video.currentTime;
            
            // Face tracking
            const faceResults = faceLandmarker.detectForVideo(video, nowInMs);
            if(faceResults.faceLandmarks && faceResults.faceLandmarks[0]) {
              drawLandmarks(faceResults.faceLandmarks[0]);
            }
            const blendshapes = faceResults.faceBlendshapes?.[0]?.categories;
            const transformMatrix = faceResults.facialTransformationMatrixes?.[0];
            
            // Pose tracking
            const poseResults = poseLandmarker.detectForVideo(video, nowInMs);
            const poseLandmarks = poseResults.landmarks?.[0];
            
            // Hand tracking
            const handResults = handLandmarker.detectForVideo(video, nowInMs);
            const handLandmarks = handResults.landmarks || [];
            
            // Apply all tracking data
            applyTracking(blendshapes, transformMatrix, poseLandmarks, handLandmarks);
          }
          
          requestAnimationFrame(detectAll);
        }

        detectAll();
        statusEl.textContent = '✨ Full body tracking active! (Face, Pose, Hands)';
      } catch(err) {
        console.error('Boot error:', err);
        statusEl.innerHTML = `<span class="err">Failed to initialize: ${err.message}</span>`;
      }
    }
    
    if(document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', boot);
    } else {
      boot();
    }
  </script>
</body>
</html>
